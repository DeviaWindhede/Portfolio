<article class="post wrapper">
    <div class="hero hero--full">
        <header>
            <h1>Vertex Painter with instanced rendering support using texture stored vertex colors</h1>
        </header>
        <figure class="hero__image post__featured-image">
            <img
                src="/assets/img/preview/vertex-painter/place-holde.png"
                srcset="
                /assets/img/preview/vertex-painter/responsive/place-holde-xs.png 300w,
                /assets/img/preview/vertex-painter/responsive/place-holde-sm.png 480w,
                /assets/img/preview/vertex-painter/responsive/place-holde-md.png 768w,
                /assets/img/preview/vertex-painter/responsive/place-holde-lg.png 1024w,
                /assets/img/preview/vertex-painter/responsive/place-holde-xl.png 1360w,
                /assets/img/preview/vertex-painter/responsive/place-holde-2xl.png 1600w"
                sizes="100vw"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >
        </figure>
    </div>


    <div class="post__entry">
        <h3>Summary</h3>
        <p>
            A Vertex Painter that stores vertex colors within a texture instead of 
            the model. Each texel represents a vertex and its corresponding color. 
            One texture is generated for each mesh that has been painted in a scene (including sub-meshes). 
            Sub mesh index is represented with a <code>_x</code> postfix.
            <br>
            These textures can vary in size and is 
            determined whilst painting depending on how many meshes have been painted on. 
            <br>
            A binary file which includes all material binding information is also generated, and is read from 
            on scene load. 
        </p>
        <p>
            The generated folder structure looks something like this
        </p>
        <pre>{{this.exampleFolderStructure}}</pre>
        <hr>

        <h3>How painting works</h3>
        <p>
            The painter itself works by sampling the G-buffer (we use a deferred rendering method within our engine) 
            in editor view to get meshes' world positions and EntityIDs in order to both get active meshes with in a scene, and to 
            translate the screen space mouse position to world position coordinates   
            <i>(The world position could be reconstructed from the depth buffer, but it we have this RTV for convenience 
                and debugging with minial performance losses)</i>. 
            When world space coordinates are retrieved, the relative position in model space is then compared to all vertices within 
            all meshes within the brush radius to find the intersecting verts. 
        </p>

        <br>

        <div class="common-grid">
            <p>
                Here's a visualization of finding the intersecting verts. 
                Mer beskrivande text h√§r wow va coolt!! :D
            </p>
            <img
                src="/assets/img/website/place-holde.png"
                srcset="
                /assets/img/website/responsive/place-holde-xs.png 300w,
                /assets/img/website/responsive/place-holde-sm.png 480w,
                /assets/img/website/responsive/place-holde-md.png 768w,
                /assets/img/website/responsive/place-holde-lg.png 1024w,
                /assets/img/website/responsive/place-holde-xl.png 1360w,
                /assets/img/website/responsive/place-holde-2xl.png 1600w"
                sizes="100vw"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >
        </div>

        <br>
        
        <p>
            The vertex color output is generated by sampling the texture that was generated by the Vertex Painter. 
            Since each pixel represents a color that is unique for each vertex within each mesh variant instance, we need to know a few things: 
        </p>
        <ul>
            <li>
                1. Which UV coordinate-span represent the vertex colors for the current mesh variant
            </li>
            <li>
                2. Which one of the colors within the span represents the current vertex that is being rendered 
            </li>
        </ul>

        <p>
            To solve the first issue, I reserved the (0, 0) location for describing the total vertex count of the mesh variant. 
            <i>
                This could be stored within a buffer and will lead to performance gains, however during development 
                this was really useful for debugging and is something that will be changed in the future.
            </i> 
            Nonetheless, the vertex count is then used to get the initial index that represents the first 
            vertex color within the span.
        </p>
        <pre>
            <code>{{vertexShaderPart1}}</code>
        </pre>

        
        <p>
            To fetch the color based using the vertex index is then achieved with some simple addition, where the appended values are 
            clamped by the texture dimensions
        </p>
        <pre>
            <code>{{vertexShaderPart2}}</code>
        </pre>


        <div class="common-grid">
            <p>
                Here's an example of the tool in action, showcasing it's potential! The draw calls also stay the same, since each mesh is 
                drawn by instance. 
                The pixel shader used simply lerps between the bound material textures on painted vertices with vertex colors as the lerp interpolator value
            </p>
            <img
                src="/assets/img/posts/vertex-painter/vertex-binding.gif"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >    
        </div>

        <p>
            As shown, tool causes vertex colors to be applied to only an affected (painted) area, even when using instanced rendering. 
            By showcasing the vertex normals, it is also easier to showcase the mesh arrangement of the testing gym.
        </p>
        <img
            src="/assets/img/posts/vertex-painter/affected-meshes.gif"
            loading="eager"
            width="960"
            height="720"
            alt=""
        >
        <h3>Conclusion</h3>
        <p>
            
        </p>
    </div>
    <app-back-to-top-btn></app-back-to-top-btn>
</article>
