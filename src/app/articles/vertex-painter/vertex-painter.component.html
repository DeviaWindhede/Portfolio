<article class="post wrapper">
    <div class="hero hero--full">
        <header>
            <h1>Vertex Painter with instanced rendering support using texture stored vertex colors</h1>
        </header>
        <figure class="hero__image post__featured-image">
            <img
                src="/assets/img/preview/vertex-painter/preview.gif"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >
        </figure>
    </div>

    <ol>
        <li>skriv färgdata till en SRV</li>
        <li>bind till SRV och visa hur vertex shadern fungerar och nämn culling problem</li>
        <li>för pixel shader, visa att den får material bundna via binära filen</li>
        <li>exportera SRV till en .dds fil</li>
        <li>försök ladda in .dds filer vid start up för att spara progress</li>
    </ol>

    <div class="post__entry">
        <h3>Summary</h3>
        <p>
            A Vertex Painter that stores vertex colors within a texture instead of 
            the model. Each texel represents a vertex and its corresponding color. 
            One texture is generated for each mesh that has been painted in a scene (including sub-meshes). 
            Sub mesh index is represented with a <code>_x</code> postfix.
            <br>
            These textures can vary in size and is 
            determined whilst painting depending on how many meshes have been painted on. 
            <br>
            A binary file which includes all material binding information is also generated, and is read from 
            on scene load. 
        </p>

        <hr>

        <h3 #selection>Implementation process</h3>
        When creating this implementation of a vertex painter, a certain data flow is vital 

 
        <p>
            This section will describe a majority of the steps I took during the process of implementing this vertex painter. 

            When making this implementation of a vertex painter it involved making large engine and rendering pipeline changes. However for this text it 
            will be summarized into the different steps taken to make the overall process work. These steps include the following: 
        </p>
        <ol>
            <li>Converting the mouse position from screen space to world space</li>
            <li>Fetching the hovered entity's ID and its corresponding mesh</li>
            <li>Perform a sphere intersection test on all vertices within the brush radius (previewing intersecting vertices can also be done here)</li>
            <li>On left click, perform all painting operations on the intersecting vertices within the selected mesh's vertex color texture</li>
            <li>A save functionality exporting the resulting textures, and importing already existing textures on start up</li>
        </ol>













        <h4>Mouse position related data collection</h4>
        <p>
            To know where the mouse is relative to the hovered entity we need its EntityID and the mouse's position in world space. 
            Unfortunately we lacked screen-to-ray support within our engine at the moment of implementing this tool, so a few work arounds were required. 

            Since our engine uses a deferred rendering pipeline, a few different RTVs are written to when rendering to the G-buffer. 
            Two of which, the "WorldPosition" RTV and the "Effects" RTV, contains some information that could be used to accommodate this. 
            The world position is self explanatory, but the Effects RTV is a little bit special. It is a R8G8B8A8_UNORM RTV where only the red and green components were being used, 
            meaning the blue and alpha components could be used to slot in the EntityID. If we combine these uint8s into a singular uint16, we can potentially access all 
            available EntityIDs within our scene's current scope. After implementing this, all data needed from the mouse position can be sampled accordingly.
        </p>
        <ngx-gist [gistId]="'73d0c768cea1e65593696c1c7ee357fe'"></ngx-gist>
        <p>
            <i>
                NOTE: The world position can be reconstructed from the depth buffer and a world position RTV is not needed. 
                However we already had the world position RTV prior to implementing the vertex painter 
                for debugging and convenience purposes, which is why was used in this implementation
            </i>
        </p>

        <h4>Vertex intersection and preview</h4>
        <p>
            Once the mouse world position and EntityID is fetched, the relative position in model space is then compared to against all vertices 
            within all meshes contained in the entity using the brush radius. These vertices are then used during brush preview and painting operations. 
            Screen space decals were originally planned to be used during the preview, however due to time constaints, this never came to be. 
            So preview is done using the debug renderer and drawing a quad for each intersecting vertex, rotated towards its normal. 
            Though the debug visualization still does make the tool much easier to use!
        </p>

        <br>

        <img
            src="/assets/img/posts/vertex-painter/vertex-selection.gif"
            loading="eager"
            width="960"
            height="720"
            alt=""
        >

        <!-- <div class="common-grid">
            <p>
                Here's a visualization of finding the intersecting verts. 
                Mer beskrivande text här wow va coolt!! :D
            </p>
            <img
            src="/assets/img/posts/vertex-painter/vertex-selection.gif"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >
        </div> -->

        <h4>Vertex color texture format</h4>
        <p>
            One of the biggest challenges when creating this tool is deciding on a texture format. 
            My approach to this problem was to assign colors as if they were part of a jagged uint32 array with a size equal to the texture size. 
            Each entry would represent a vertex color and its location based on the SV_VertexID semantic. 
            What's tricky about this however, is knowing where the intial uv location each instance should derive from.
        </p>
        <p>
            At first I considered linking the initial index to the SV_InstanceID semantic, but discarded that thought since culling would have a severe impact. 
            What I ended up using was giving each entity its own unique index thats incrementally assigned during painting, meaning the first painted entity 
            of a mesh type would be given the value 0 and following entities of the same mesh type would have incremented values of 1, 2, 3 and so on. 
            These indices would then be saved into a binary file that is loaded every scene change. The indices are related to the EntityID, meaning that if they EntityID would change 
            due to ID recycling or scene changes post painting, they would become missmatched. However since the painting is only done on static geometry, and all levels during 
            our development cycles are created in segments and are also never vertex painted until finalized, it never becomes a problem.
        </p>
        <ngx-gist [gistId]="'cc0015879ec9b360b2d52a3dba56fa10'"></ngx-gist>
        <p>
            You may notice the +1 when calculating the step offset. Since each step is dependant on the vertex count, I avoided the use of a buffer to send the vertex 
            count and instead reserved the (0, 0) coordinate to contain the value. This decision was made early on to aid in debugging and to reduce overhead. Here are some 
            examples on the resulting layout: 
        </p>

        <div class="common-grid">
            <img
                src="/assets/img/posts/vertex-painter/color-snippet.png"
                loading="eager"
                width="960"
                height="720"
                alt=""
                class="child-padding"
            >
            <img
                src="/assets/img/posts/vertex-painter/vertex-wrapping.png"
                loading="eager"
                width="960"
                height="720"
                alt=""
                class="child-padding"
            >
        </div>
        <p>
            The first image (left-to-right on larger resolutions) is a 22x3 snippet from the of the top-left most UVs of a 1024x1024 vertex color texture that is currently used within one of our games. 
            The alpha channel has been set to 255 to be able to visualize the texture structure. Since the (0, 0) color is {{'{ 20, 0, 0, 0 }'}}, it means that 
            the current mesh has a vertex count of 20, meaning every 20 * vertexPaintedIndex + 1 pixels in the texture represents another mesh instance.
        </p>

        <h4>Vertex color mapping</h4>
        <p>
            Once the format is established, all that is left to allow painting is to save the color information to an SRV and have it bound as a vertex shader resource. 
            To save the color information, I created a staging texture that copies.

            
        </p>
        <p>
            When saving to 
        </p>
        <ngx-gist [gistId]="'09de3d0826021d041c1d1d8359cf3193'"></ngx-gist>

        <br>

        <h4>Vertex texture binding</h4>

        <p>
            Since there can exist multiple meshes within one .fbx file, each sub-mesh is given its own texture. Due to this the generated textures 
            use the naming convension of <code>{{'meshName_{subMeshIndex}'}}</code> so it texture binding becomes as straight forward as possible. 
            Generated vertex color textures use the R8G8B8A8_UNORM color format, and the resulting folder structure looks something like this:
        </p>
        <pre>{{this.exampleFolderStructure}}</pre>

        <br>
        
        <p>
            The vertex color output is generated by sampling the texture that was generated by the Vertex Painter. 
            Since each pixel represents a color that is unique for each vertex within each mesh variant instance, we need to know a few things: 
        </p>
        <ul>
            <li>
                1. Which UV coordinate-span represent the vertex colors for the current mesh variant
            </li>
            <li>
                2. Which one of the colors within the span represents the current vertex that is being rendered 
            </li>
        </ul>

        <p>
            To solve the first issue, I reserved the (0, 0) location for describing the total vertex count of the mesh variant. 
            <i>
                This could be stored within a buffer and will lead to performance gains, however during development 
                this was really useful for debugging and is something that will be changed in the future.
            </i> 
            Nonetheless, the vertex count is then used to get the initial index that represents the first 
            vertex color within the span.
        </p>
        <pre>
            <code>{{vertexShaderPart1}}</code>
        </pre>

        
        <p>
            To fetch the color based using the vertex index is then achieved with some simple addition, where the appended values are 
            clamped by the texture dimensions
        </p>
        <pre>
            <code>{{vertexShaderPart2}}</code>
        </pre>


        <div class="common-grid">
            <p>
                Here's an example of the tool in action, showcasing it's potential! The draw calls also stay the same, since each mesh is 
                drawn by instance. 
                The pixel shader used for this showcase simply lerps between the bound material textures based on the vertex colors as the lerp interpolator value, 
                on the albedo, pixel normal, material and emissive output textures to the G-buffer
            </p>
            <img
                src="/assets/img/posts/vertex-painter/vertex-binding.gif"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >    
        </div>

        <p>
            The painter also works on an per-entity selection mode, where the user is restricted to painting on meshes they have selected prior to painting (during "Object Selection Mode"). 
            However, if no meshes are selected, it simply paints on the object the mouse is currently hovering over. 
        </p>

        <h3>Conclusion and Final thoughts</h3>
        <p>
            This is a way of implementing vertex painting without any vertex data creation or modification. Some perks with this is that it is really easy and intuitive to 
            render all painted meshes using instanced draw calls. 
            The figure blow visualizes how the vertex painter causes vertex colors to only be applied to an affected (painted) area, even when using instanced rendering. 
            The vertex normals without any face culling are shown to more easily showcase the mesh arrangement of the scene.
        </p>
        <img
            src="/assets/img/posts/vertex-painter/affected-meshes.gif"
            loading="eager"
            width="960"
            height="720"
            alt=""
        >
        <p>
            Since all vertex data is stored in textures using a linear pattern, it is also possible to combine them all into a mega texture in the future! 
            The performance hits to consider is the texture sampling done in the vertex shader and the RAM usage with slot bindings and the textures SRVs being stored in memory and the painting performance as well.  
            So all in all, it works quite well! c:
        </p>

        <p>
            Due to a time crunch, I never got the opportunity to implement decals that showcase selected vertices and brush radius.
            Because of this, <a (click)="scrollToSelection()">I used some debug gizmos (DirectXTK) to draw quads rotated towards the vertex normals to get some type of visualization.</a> 
            Though it is something that I would love to do in the future! Especially since we use a deferred rendering method  
        </p>
    </div>
    <app-back-to-top-btn></app-back-to-top-btn>
</article>
