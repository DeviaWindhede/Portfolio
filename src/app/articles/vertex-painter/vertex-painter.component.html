<article class="post wrapper">
    <div class="hero hero--full">
        <header>
            <h1>Vertex Painter with instanced rendering support using texture stored vertex colors</h1>
        </header>
        <figure class="hero__image post__featured-image">
            <img
                src="/assets/img/preview/vertex-painter/place-holde.png"
                srcset="
                /assets/img/preview/vertex-painter/responsive/place-holde-xs.png 300w,
                /assets/img/preview/vertex-painter/responsive/place-holde-sm.png 480w,
                /assets/img/preview/vertex-painter/responsive/place-holde-md.png 768w,
                /assets/img/preview/vertex-painter/responsive/place-holde-lg.png 1024w,
                /assets/img/preview/vertex-painter/responsive/place-holde-xl.png 1360w,
                /assets/img/preview/vertex-painter/responsive/place-holde-2xl.png 1600w"
                sizes="100vw"
                loading="eager"
                width="960"
                height="720"
                alt=""
            >
        </figure>
    </div>


    <div class="post__entry">
        <h3>Summary</h3>
        <p>
            A Vertex Painter that stores vertex colors within a texture instead of 
            the model. Each texel represents a vertex and its corresponding color. 
            One texture is generated for each mesh that has been painted in a scene (including sub-meshes). 
            Sub mesh index is represented with a <code>_x</code> postfix.
            <br>
            These textures can vary in size and is 
            determined whilst painting depending on how many meshes have been painted on. 
            <br>
            A binary file which includes all material binding information is also generated, and is read from 
            on scene load. 
        </p>
        <p>
            The generated folder structure looks something like this
        </p>
        <pre>{{this.exampleFolderStructure}}</pre>
        <hr>

        <h3>How painting works</h3>
        <p>
            The painter itself works by sampling the G-buffer (we use a deferred rendering method within our engine) 
            in editor view to get meshes' world positions and EntityIDs in order to both get active meshes with in a scene, and to 
            translate the screen space mouse position to world position coordinates   
            <i>(The world position could be reconstructed from the depth buffer, but it we have this RTV for convenience 
                and debugging with minial performance losses)</i>. 
            When world space coordinates are retrieved, the relative position in model space is then compared to all vertices within 
            all meshes within the brush radius to find the intersecting verts. 
        </p>

        <b>cool gif om mesh intersections!! coolt om det fanns decaler f√∂r visualisering</b>
        <img
            src="/assets/img/website/place-holde.png"
            srcset="
            /assets/img/website/responsive/place-holde-xs.png 300w,
            /assets/img/website/responsive/place-holde-sm.png 480w,
            /assets/img/website/responsive/place-holde-md.png 768w,
            /assets/img/website/responsive/place-holde-lg.png 1024w,
            /assets/img/website/responsive/place-holde-xl.png 1360w,
            /assets/img/website/responsive/place-holde-2xl.png 1600w"
            sizes="100vw"
            loading="eager"
            width="960"
            height="720"
            alt=""
        >

        <br>
        
        <h3>Conclusion</h3>
        <p>
            
        </p>
    </div>
    <app-back-to-top-btn></app-back-to-top-btn>
</article>
